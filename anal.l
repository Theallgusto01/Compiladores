%option noyywrap
%{
    #include <string.h>
    #include <stdlib.h>
    #include <ctype.h>
    #include "sintatico.tab.h"  /* generated by bison -d */

   
#ifndef TIPO_INTEIRO
#define TIPO_INTEIRO 3000
#endif
#ifndef TIPO_DECIMAL
#define TIPO_DECIMAL 3001
#endif
#ifndef TIPO_LOGICO
#define TIPO_LOGICO 3002
#endif
#ifndef TIPO_CARACTERE
#define TIPO_CARACTERE 3003
#endif
#ifndef LOGICO_VERDADEIRO
#define LOGICO_VERDADEIRO 3004
#endif
#ifndef LOGICO_FALSO
#define LOGICO_FALSO 3005
#endif
#ifndef OPERADOR_IGUALDADE
#define OPERADOR_IGUALDADE 3006
#endif
#ifndef OPERADOR_DIFERENCA
#define OPERADOR_DIFERENCA 3007
#endif
#ifndef OPERADOR_LOGICO_AND
#define OPERADOR_LOGICO_AND 3008
#endif
#ifndef OPERADOR_LOGICO_OR
#define OPERADOR_LOGICO_OR 3009
#endif
#ifndef OPERADOR_DIVISAO_INTEIRA
#define OPERADOR_DIVISAO_INTEIRA 3010
#endif
#ifndef OPERADOR_MENOR
#define OPERADOR_MENOR 3011
#endif
#ifndef OPERADOR_MAIOR
#define OPERADOR_MAIOR 3012
#endif
#ifndef DELIMITADOR
#define DELIMITADOR 3013
#endif
#ifndef FIM_DE_LINHA
#define FIM_DE_LINHA 3014
#endif
%}

%x COMMENT


IGNORE [ \t\r\n]+
DELIMITADOR [\{\}\[\]\(\)]
EOL ;

%%

"//".*                { /* ignora comentário de linha */ }
"/*"                     { BEGIN(COMMENT); }
<COMMENT>"*/"            { BEGIN(INITIAL); }
<COMMENT>(.|\n)          { /* consome corpo do comentário */ }

    
"int"                    { return TIPO_INTEIRO; }
"dec"                    { return TIPO_DECIMAL; }
"log"                    { return TIPO_LOGICO; }
"car"                    { return TIPO_CARACTERE; }

    
"leia"                   { return FUNC_LEITURA; }
"escreva"                { return FUNC_ESCRITA; }
"raiz"                   { return FUNC_RAIZ; }

"true"                   { return LOGICO_VERDADEIRO; }
"false"                  { return LOGICO_FALSO; }

   
"=="                     { return OPERADOR_IGUALDADE; }
"!="                     { return OPERADOR_DIFERENCA; }
"&&"                     { return OPERADOR_LOGICO_AND; }
"||"                     { return OPERADOR_LOGICO_OR; }
"%"                      { return OPERADOR_DIVISAO_INTEIRA; }
"<"                      { return OPERADOR_MENOR; }
">"                      { return OPERADOR_MAIOR; }

   
"+"                      { return '+'; }
"-"                      { return '-'; }
"*"                      { return '*'; }
"/"                      { return '/'; }

"="                      { return '='; }

    
"inicio"                 { return INI; }
"fim"                    { return FIM; }


"("   { return '('; }
")"   { return ')'; }
"{"   { return '{'; }
"}"   { return '}'; }

    
\"([^\\\"\n])*\"    {             
                                                        int len = yyleng;
                                                        yytext[len-1] = '\0';
                                                        strncpy(yylval.string, yytext+1, 99);
                                                        yylval.string[99] = '\0';
                                                        return TOK_STRING;
                                                    }

[a-zA-Z_][a-zA-Z0-9_]*      {
                            char c = yytext[0];
                            if (isalpha((unsigned char)c))
                                yylval.inteiro = tolower((unsigned char)c) - 'a';
                            else
                                yylval.inteiro = 0;
                            return IDENTIFICADOR;
                          }

[0-9]+\.[0-9]+            { yylval.real = atof(yytext); return DECIMAL; }
[0-9]+                    { yylval.real = atof(yytext); return INTEIRO; }


{IGNORE}                  {}

.                         {return yytext[0]; }

%%